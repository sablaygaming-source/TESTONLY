############################
#    JS

Method,Type,Result

gateData: data,                   Reference,                        Changing one changes the other completely.
gateData: [...data],              Shallow Copy,                "Safe from adding/removing, but not safe from editing internal values."
JSON.parse(JSON.stringify(data)),  Deep Copy,                  100% Safe. Totally separate data.



JS sample text format
let user = {name: "ando"};
console.log(`Data: ${user}`);

Reviewer Output: Data: [object Object]


let user = {name: "ando"};
console.log(`Data: ${JSON.stringify(user)}`);

Reviewer Output: Data: {"name":"ando"}

TAKE NOTE: 
In JavaScript, the ${data} syntax is much more strict. It calls the .toString() method. For objects, 
the default "string" is unfortunately just the type name: [object Object].

You hit on one of the biggest "annoyances" when switching between Python and JavaScript!

In Python, the f"{data}" string automatically calls a method called __str__ on the object. Python is designed to 
be "human-readable," so it tries its best to turn that dictionary into a string that looks like code.

In JavaScript, the ${data} syntax is much more strict. It calls the .toString() method. For objects, the default 
"string" is unfortunately just the type name: [object Object].




1. The Comparison: Python vs. JS
Here is why you feel Python is easier for this specific task:



Python (Auto-format):

Python
user = {"name": "ando"}
print(f"Data: {user}")
Reviewer Output: Data: {'name': 'ando'}

JavaScript (The "Stupid" way):

JavaScript
let user = {name: "ando"};
console.log(`Data: ${user}`);
Reviewer Output: Data: [object Object]

JavaScript (The Fixed way):

JavaScript
let user = {name: "ando"};
console.log(`Data: ${JSON.stringify(user)}`);
Reviewer Output: Data: {"name":"ando"}

2. Why JavaScript requires JSON.stringify
JavaScript treats an Object as a "complex memory reference." It doesn't want to guess how you want to see that 
data (maybe you want it as XML? maybe as a list?).

By using JSON.stringify(), you are explicitly telling the machine: "Convert this memory object into a JSON-formatted string."


Reviewer Samples: JS Object Displays
Sample A: Single Property (No stringify needed)
Code:

let user = { name: "ando" };
let msg = `User: ${user.name}`;

Reviewer Output: User: ando


Sample B: Whole Object (Stringify required)
Code:

let user = { name: "ando", id: 12 };
let msg = `Data: ${JSON.stringify(user)}`;

Reviewer Output: Data: {"name":"ando","id":12}


## Summary
* **Python:** Uses `__str__` which defaults to a readable version of the dictionary.
* **JavaScript:** Uses `.toString()` which defaults to the internal class name `[object Object]`. 
* **The Solution:** Always use `JSON.stringify()` in JS if you want to see the "insides" of the object in a string.

Addition (Concatenation)
let data = "abc"; 
data = data + 1;

Reviewer Output: abc1


let route = "GROUP0";
let check = route.toLowerCase();

Reviewer Output: group0


let route = "group0_active";
let check = route.includes("group0");

Reviewer Output: true


String Length

let val = "abc";
let check = val.length;

Reviewer Output: 3


Splitting to Array

let path = "user/ando/123";
let check = path.split("/");

Reviewer Output: ["user", "ando", "123"]


Trimming Whitespace

let input = "  data  ";
let check = input.trim();

Reviewer Output: data



Character Extraction

let word = "JavaScript";
let check = word.charAt(0);

Reviewer Output: J



 Substring Slice
let id = "USR_99821";
let check = id.slice(4);

Reviewer Output: 99821



Type Coercion (Number to String)


let num = 500;
let check = num.toString() + "px";


Reviewer Output: 500px



Array Index Injection
Accessing a specific value from a list.

let names = ["ando", "bert", "carlo"];
let msg = `The winner is ${names[0]}`;

Reviewer Output: The winner is ando



Object Property Injection
Accessing a specific "key" inside an object.

let user = { name: "ando", id: 123 };
let msg = `User ID for ${user.name} is ${user.id}`;

Reviewer Output: User ID for ando is 123



The "Raw Object" Trap (What to Avoid)
If you put the whole object inside the ${}, it breaks.

let user = { name: "ando" };
let msg = `Data: ${user}`;

Reviewer Output: Data: [object Object]



Object to JSON String
If you want to see the whole object inside the text (useful for debugging).

let user = { name: "ando", role: "admin" };
let msg = `Payload: ${JSON.stringify(user)}`;

Reviewer Output: Payload: {"name":"ando","role":"admin"}


Array Length Injection
Using a property of the array inside the string.

let items = [10, 20, 30, 40];
let msg = `You have ${items.length} items in your cart`;

Reviewer Output: You have 4 items in your cart


Logic inside the ${}
You can actually perform "Algorithms" directly inside the template.

let data = [10, 20];
let msg = `Total: ${data[0] + data[1]}`;

Reviewer Output: Total: 30


Accessing Objects inside an Array
Common for database results like your smallData.

let users = [{ name: "ando" }, { name: "bert" }];
let msg = `First user is ${users[0].name}`;

Reviewer Output: First user is ando


Input Type,                 Code,                   Reviewer Output
Array,                     ${arr[0]},               Returns first item value
Object,                    ${obj.key},              Returns property value
Object,                    ${obj},                  [object Object] (Wrong)
JSON,                    ${JSON.stringify(obj)},     Returns string version of object



.push() (Add to end)
Adds an item to the end of the array. Note: This changes the original array. Code:

let names = ["ando", "bert"];
names.push("carlo");
// names is now: ["ando", "bert", "carlo"]


.pop() (Remove from end)
Removes the very last item. Code:

let names = ["ando", "bert", "carlo"];
let removed = names.pop();
// names is now: ["ando", "bert"]



.shift() (Remove from start)
Removes the first item (index 0). Code:

let names = ["ando", "bert"];
names.shift();
// names is now: ["bert"]


.unshift() (Add to start)
Adds an item to the very beginning. Code:

let names = ["bert"];
names.unshift("ando");
// names is now: ["ando", "bert"]



.map() (The Transformer)
Creates a new array by doing something to every item. Code:

let nums = [1, 2, 3];
let doubled = nums.map(n => n * 2);
// doubled is: [2, 4, 6]


.filter() (The Gatekeeper)
Creates a new array containing only items that pass a test. Code:

let scores = [10, 50, 80];
let highScores = scores.filter(s => s > 40);
// highScores is: [50, 80]


.includes() (The Searcher)
Checks if an item exists in the list. Code:

let fruits = ["apple", "banana"];
let check = fruits.includes("apple");
// check is: true


.join() (Array to String)
Flattens the array into a single string. Code:

let parts = ["user", "ando", "123"];
let path = parts.join("/");
// path is: "user/ando/123"


.slice() (The Cutter)
Copies a portion of the array without changing the original. Code:

let all = ["a", "b", "c", "d"];
let middle = all.slice(1, 3); 
// middle is: ["b", "c"]


[...array] (The Spreader)
Creates a shallow copy (great for your smallData logic). Code:

let original = [1, 2];
let copy = [...original, 3];
// copy is: [1, 2, 3]


Method,                Changes Original?,             Best Use Case
push / pop,             Yes,                          Managing a simple list
map,                    No,                          Changing data format (e.g. names to objects)
filter,                 No,                          Removing unwanted data
join,                   No,                          Preparing data for a URL or String



Mapping Arrays to Objects
This is exactly what you need when you have raw data (like names) and need to turn them into structured database rows. Code:

let names = ["ando", "bert"];
let databaseRows = names.map((item, index) => {
  return { id: index + 1, username: item, status: "active" };
});
// databaseRows is: [{"id":1,"username":"ando","status":"active"},{"id":2,"username":"bert","status":"active"}]


Deep Extraction (Nested Objects)
Use this when you have a complex array of objects and you only want to pull out one specific property into a new list. Code:

let users = [
  { info: { name: "ando", age: 25 } },
  { info: { name: "bert", age: 30 } }
];
let justNames = users.map(u => u.info.name);
// justNames is: ["ando", "bert"]


Conditional Mapping
Changing the data based on a specific condition (The "Algorithm" style). Code:

let prices = [100, 200, 300];
let discounted = prices.map(p => p > 150 ? p * 0.9 : p);
// discounted is: [100, 180, 270]


Flattening Nested Arrays (.flatMap)
If your map results in "arrays inside arrays," this method "squashes" them into one single flat


let tagsPerUser = [["urgent", "api"], ["v1"]];
let flatTags = tagsPerUser.flatMap(t => t);
// flatTags is: ["urgent", "api", "v1"]



Combining Two Arrays (Zip)
Using the index to "marry" data from two different lists. Code:

let users = ["ando", "bert"];
let ids = [101, 102];
let combined = users.map((u, i) => `${u}_${ids[i]}`);
// combined is: ["ando_101", "bert_102"]


Creating an "Index Map" Object
Sometimes you want to turn an array into a single object for fast lookup. This uses .reduce().

let list = [{id: "a1", val: 10}, {id: "b2", val: 20}];
let lookupMap = list.reduce((acc, obj) => {
  acc[obj.id] = obj.val;
  return acc;
}, {});
// lookupMap is: {"a1":10, "b2":20}

Method,                 Best For...,                       Copy-Paste Logic
.map(),                Changing data format,               arr.map(x => x * 2)
.filter(),             Removing items,                     arr.filter(x => x > 0)
.flatMap(),            Cleaning nested lists,              arr.flatMap(x => x)
.reduce(),             Turning Array into 1 Object,        "arr.reduce((a, b) => ...)"


The for...of Loop (The "Modern" Choice)
This is the cleanest way to iterate over array values. It is very readable and works perfectly with async/await.

let users = ["ando", "bert", "carlo"];
let result = "";

for (let name of users) {
  result += name + "_";
}
// result is: "ando_bert_carlo_"

other sample
let users = ["ando", "bert", "carlo"];

for (let value of users) {
  console.log(value);
}
// Result: // "ando"
// Result: // "bert"
// Result: // "carlo"


The forEach() Method (The "Callback" Style)
Great for simple operations where you don't need to return a new array. Note: You cannot "break" or "continue" out of a forEach.

let prices = [10, 20, 30];
let total = 0;

prices.forEach((num) => {
  total += num;
});
// total is: 60


dvanced: Looping through Objects (for...in)
If your "array" is actually an Object, you use for...in to get the keys.

let statusMap = { ando: "online", bert: "offline" };
let report = [];

for (let key in statusMap) {
  report.push(`${key} is ${statusMap[key]}`);
}
// report is: ["ando is online", "bert is offline"]

other sample
let users = ["ando", "bert", "carlo"];

for (let key in users) {
  console.log(key); 
}
// Result: // "0"
// Result: // "1"
// Result: // "2"


Loop             Type,Use                            Case,Can use break?
for...of,         Read values from an array,           Yes
forEach,          Run a function for every item,        No
for (let i...),   When you need the index number,      Yes
for...in,Looping   through Object keys,                 Yes


Number to String Conversion
Use this when you need to prepare a number for a URL, a message, or an n8n field.

let num = 123;
let result = num.toString();
// result is: "123" (String)


. String to Number (Integer & Double)
JavaScript uses Number() as a general tool, but parseInt and parseFloat are better for specific math.


let data = "100";
let result = parseInt(data);
// result is: 100 (Number)


	
Code (Double / Float):

let price = "19.99";
let result = parseFloat(price);
// result is: 19.99 (Number)


formatting Decimals (The "Double" Format)
Use .toFixed(n) to control how many numbers appear after the decimal point. Note: This turns the result back into a String.

let pi = 3.14159;
let result = pi.toFixed(2);
// result is: "3.14" (String)



The Blockers (What stops your code)
These are the most common "Stupid Machine" errors that will cause your code to return NaN (Not a Number) or wrong values.

Blocker A: The "NaN" Trap
If you try to convert a string that contains letters, it fails. Code:

let badData = "abc123";
let result = Number(badData); 
// result is: NaN


The "Addition" Trap (Coercion)
If you forget to convert a string to a number before adding, it just joins them. Code:

let val = "10";
let result = val + 5; 
// result is: "105"


C: The "Empty String" Trap
Converting an empty string or a string with only spaces. Code:

let empty = "  ";
let result = Number(empty); 
// result is: 0 (This is dangerous for logic!)


Input,       Target,        Code,                  Reviewer Output
"""42""",    Integer,     "parseInt(""42"")"       ,42
"""42.5""",  Double,      "parseFloat(""42.5"")"    ,42.5
100,         String,  (100).toString()              ,"""100"""
5.678,2      Decimals,(5.678).toFixed(2),           """5.68"""



Here is how you use isNaN() (which stands for "is Not a Number") 
to validate your data. I have included the "Safe" and "Unsafe" patterns.

The Basic "Safety Check"
Use this to decide if you should proceed with math or return an error.

let dbValue = "123.45";
let isSafe = !isNaN(dbValue); 
// isSafe is: true (Because "123.45" can be a number)


. Handling "Dirty" Data (The Blocker)
If the database sends a unit (like "100px") or a name, isNaN() catches it.

let dbValue = "ando_123";
let isSafe = !isNaN(dbValue); 
// isSafe is: false


The "Guard Clause" Pattern
This is the "Hard" sample. Itâ€™s a clean way to write code that stops immediately if the data is bad.

let input = "50.5";
let result;

if (isNaN(input) || input === "") {
  result = "Error: Invalid Number";
} else {
  result = parseFloat(input) * 2;
}
// result is: 101


Advanced: Number.isFinite()
isNaN() is good, but Number.isFinite() is even "Harder" (safer) because it also blocks things like Infinity or null.

let val = null;
let check = Number.isFinite(val);
// check is: false (Safe choice!)


Input,isNaN() Result,  Logic Meaning
"""100""",   false,    Safe to convert
100,         false,   Safe (already a number)
"""abc""",   true,    Unsafe (will result in NaN)
undefined,   true,    Unsafe


The Blocker (Why it fails)
An Array is an ordered list. It has the .map() function built-in. An Object is a collection of keys and values;
 it does not have a .map() function.
let myObj = { "user[1]": "ando", "user[2]": "bert" };

// This will throw: "TypeError: myObj.map is not a function"
// myObj.map(u => u); 

// Result: // CRASH (n8n node stops)



The Solution: Convert to Array First
To use .map() logic, you must transform the Object into an Array using one of these three Object methods.

A. Using Object.keys()
Use this when you want to loop through the labels (like user[1]).

let body = { "user[1]": { name: "ando" }, "user[2]": { name: "bert" } };

let keys = Object.keys(body).map(key => key); 

console.log(keys); 
// Result: // ["user[1]", "user[2]"]



B. Using Object.values()
Use this when you only care about the bank data inside the keys.

let body = { "user[1]": { BankName: "BDO" }, "user[2]": { BankName: "BPI" } };

let banks = Object.values(body).map(data => data.BankName);

console.log(banks);
// Result: // ["BDO", "BPI"]



C. Using Object.entries()
Use this when you need both the key name and the data at the same time.

let body = { "user[1]": { status: "OK" } };

let entries = Object.entries(body).map(([key, value]) => {
    return `${key} is ${value.status}`;
});

console.log(entries);
// Result: // ["user[1] is OK"]


## ANOTHER SAMPLE OF OBJECT.ENTRIES
const user = { name: "ando", status: "active" };

//easiy access the keys and value by using [] literal array
Object.entries(user).forEach(([key, value]) => {
    console.log(`The field is ${key} and the data is ${value}`);
});

/*
--- CONSOLE OUTPUT ---
The field is name and the data is ando
The field is status and the data is active
*/




Input Type,Code,Reviewer Output
Array [],"[1, 2].map(x => x)","// [1, 2]"
Object {},obj.map(...),// ERROR: Not a function
Object {},Object.values(obj).map(...),// [transformed_data]

in SPLIT and CONSOLE.LOG  BACKTICKS  `${}`
inputText = "id,name,email\n1,ando,ando@email\n2,bert,bert@email\n3,car,car@email";
unProcessData = inputText.split('\n');
console.log(`unProcessData = ${unProcessData}`);
console.log(`\n\nanother test unProcessData = ${JSON.stringify(unProcessData, null, 2)}`);

output:
unProcessData = id,name,email,1,ando,ando@email,2,bert,bert@email,3,car,car@email


another test unProcessData = [
  "id,name,email",
  "1,ando,ando@email",
  "2,bert,bert@email",
  "3,car,car@email"
]

    
explanation 
1. The "String Conversion" Behavior
In your first console log:
console.log(unProcessData = ${unProcessData});
When you put an Array inside a template literal, JavaScript automatically calls .toString() 
on that array. For an array, .toString() joins all elements with a comma.
Since your split('\\n') failed to find a literal \ and n, your array only has one giant 
string in it.

JavaScript prints that one string. Because that string contains a real newline character (\n), 
the console physically moves to the next line when printing it.

2. The "Structure" Behavior
In your second console log:
console.log(another test = ${JSON.stringify(unProcessData)});

JSON.stringify does not "run" the newline character; it treats it as data. It shows you the actual 
structure of the variable. It shows:
["id,name,email\n1,ando..."]

This confirms that unProcessData is an array with only 1 item. The split didn't happen.

note good using ${JSON.stringify(unProcessData, null, 2)}  the use of 2nd and 3rd parameters null and 2
it show clear the value of an array remember ALWAYS USE JSON.stringify in displaying array and objects
, in single variable like numbers strings no stringify needed


tip pro convertion of csvtext to arrays of object

const rows = inputText.split(/\r?\n/);
const headers = rows[0].split(','); // ["id", "name", "email"]

const dataObjects = rows.slice(1).map(row => {
    const values = row.split(',');
    return {
        id: values[0],
        name: values[1],
        email: values[2]
    };
});

return dataObjects;


When you see / / in JavaScript, you aren't looking at a String; you are looking at a Regular Expression (Regex).

Think of a String (" ") as a "Static Value" and a Regex (/ /) as a "Search Pattern."

Feature                "String: "\n"   ,                                             Regex: /\r?\n/
Search Style,          Matches exactly those characters.,                            Matches a pattern of characters.
Flexibility,           Rigid. If the file has a ""Carriage Return"" (\r),it fails.   Flexible. It can find different types of line breaks at once.
The "Optional" ?,      Cannot do this.                                               The ? means "The character before me is optional."



###  FILTER     MAP   FOREACH  
## CONVERTING STRING TO ARRAY OF OBJECT
function fFilter() {
    console.log(`\n process of using .filter() \n`);
    inputText = "id,name,email\n1,ando,ando@email\n2,bert,bert@email\n3,car,car@email";
    unProcessData = inputText.split('\n');
    headers = unProcessData[0].split(',');

    // map automatically gives you the index as the second argument (i)
    resultData = unProcessData.map((unFilterRows, i) => {
        // Skip the header row (index 0)
        if (i === 0) return null;

        // CREATE A NEW OBJECT ADDRESS HERE
        let dataRows = {};
        let filterRows = unFilterRows.split(',');
        filterRows.forEach((values, headersIndex) => {
            dataRows[headers[headersIndex]] = values;
        });
        return dataRows;
    }).filter(item => item !== null); // Clean out the null from the header row

    console.log(JSON.stringify(resultData, null, 2));
    return resultData;
}
//OUTPUT IS
process of using .filter()
[
  {
    "id": "1",
    "name": "ando",
    "email": "ando@email"
  },
  {
    "id": "2",
    "name": "bert",
    "email": "bert@email"
  },
  {
    "id": "3",
    "name": "car",
    "email": "car@email"
  }
]


##   REDUCE   MAP   SPLIT  SLICE


function fModernWay() {
    console.log(`modern way`);
    inputText = "id,name,email\n1,ando,ando@email\n2,bert,bert@email\n3,car,car@email";
    const rows = inputText.split('\n');
    const headers = rows[0].split(',');

    const result = rows.slice(1).map(row => {
        const values = row.split(',');

	//remember obj holds the object data, header holds the keynames, index holds the index loop ex: 0 1 2
        return headers.reduce((obj, header, index) => {

	    //at initial line obj is []
            obj[header] = values[index]; //example input keys id: value 1 is {"id":"1"}
				       //the next loop is {"id":"1"} added keys name : value "ando" is {"id":"1","name":"ando"}
                                       //now you know the 3rd it is {"id":"1","name":"ando","email":"ando@email"}

            console.log(`inside headers.reduce ${JSON.stringify(obj)}`); //observe the output here

	    //pass the obj to preserve the objects keys
            return obj;

        }, {}); // The {} here creates the new object for every row automatically
	       //this is initial value creates and empty { } for every initial call of .reduce( )
    });
    return result;
}

... fMain() {

    resultData = fModernWay();
    console.log(`${JSON.stringify(resultData, null, 2)}`);

OUTPUT:
modern way
inside headers.reduce {"id":"1"}
inside headers.reduce {"id":"1","name":"ando"}
inside headers.reduce {"id":"1","name":"ando","email":"ando@email"}
inside headers.reduce {"id":"2"}
inside headers.reduce {"id":"2","name":"bert"}
inside headers.reduce {"id":"2","name":"bert","email":"bert@email"}
inside headers.reduce {"id":"3"}
inside headers.reduce {"id":"3","name":"car"}
inside headers.reduce {"id":"3","name":"car","email":"car@email"}
[
  {
    "id": "1",
    "name": "ando",
    "email": "ando@email"
  },
  {
    "id": "2",
    "name": "bert",
    "email": "bert@email"
  },
  {
    "id": "3",
    "name": "car",
    "email": "car@email"
  }
]


## .REDUCE  ANOTHER SAMPLE TO MAKE IT CLEAR FOR U

function fProcessArray() {

    const users = [
        { name: 'ando', status: 'active' },
        { name: 'bert', status: 'deactive' },
        { name: 'carl', status: 'active' }
    ];

    const activeCount = users.reduce((total, user) => {
        console.log(`inside users.reduce total is ${JSON.stringify(total)}`)
        if (user.status === 'active') {
            total.push(1);
            //to preserve the value u must return it
            return total;
        }

        //to preserve the value u must return it
        return total;
    }, ["start"]);

    /*
    --- CONSOLE OUTPUT ---
    before entering round1 total is ["start"] because of the bottom
    Round 1: total is ["start"], 'ando' is active. total.push(1) Returns total = ["start",1]. //returns total to preserve the data in next loop
    Round 2: total is ["start",1]. 'bert' is deactive. jumps to false line then Returns total = ["start",1].
    Round 3: total is ["start",1]. 'carl' is active. Returns total  = ["start",1,1]. //now final return is ["start",1,1] 
    
    --- FINAL RETURN VALUE ---
    ["start",1,1]
    */

    console.log(`result is ${JSON.stringify(activeCount, null, 2)}`);
    console.log(`result is ${activeCount}`);

}


.... fMain() {

    fProcessArray();

OUTPUT:
inside users.reduce total is ["start"]
inside users.reduce total is ["start",1]
inside users.reduce total is ["start",1]
result is [
  "start",
  1,
  1
]
result is start,1,1


TAKE NOTE:  if you want to return by array or object u must use .reduce( (accumulator, array, index) =>{..etc}, startValue)
the startValue = [] for array or {} for object, but if u put 0 or string it will return a string



##  MAP  SPLIT  SLICE   OLDWAY PROGRAMMING

function fOldWay() {
    console.log(`the OldWay`);
    inputText = "id,name,email\n1,ando,ando@email\n2,bert,bert@email\n3,car,car@email";
    const rows = inputText.split('\n');
    const headers = rows[0].split(',');

    // Start from the second row and map each to an object
    const result = rows.slice(1).map(row => {
        const values = row.split(',');

        // We build the object in one shot
        const rowObject = {
            [headers[0]]: values[0],
            [headers[1]]: values[1],
            [headers[2]]: values[2]
        };

        // Your favorite part: Printout the result of this specific row
        console.log("Processed Row:", rowObject);
        return { json: rowObject };
    });
    return result;
}

//..in main()
data = fOldWay();
console.log(`data is ${JSON.stringify(data, null, 2)} `);

//OUTPUT
the OldWay
Processed Row: { id: '1', name: 'ando', email: 'ando@email' }
Processed Row: { id: '2', name: 'bert', email: 'bert@email' }
Processed Row: { id: '3', name: 'car', email: 'car@email' }
data is [
  {
    "json": {
      "id": "1",
      "name": "ando",
      "email": "ando@email"
    }
  },
  {
    "json": {
      "id": "2",
      "name": "bert",
      "email": "bert@email"
    }
  },
  {
    "json": {
      "id": "3",
      "name": "car",
      "email": "car@email"
    }
  }
]

## DIFFERENT KINDS OF DISPLAYING OBJECT WITH COMPLETE INFORMATION
Tool,                                     Environment,         Use Case
console.dir(obj)                          Browser,             When you want to see all hidden properties and methods of an element.
"console.dir(obj, {depth: null})"         Node.js / n8n,       When you want the console to stop hiding deep data behind [Object].
"JSON.stringify(obj, null, 2)"            Anywhere,            "When you want a pretty-printed string you can save, send, or display."


A Warning for the Browser
If you try to use depth: null in a standard browser script, it won't crash, but it won't do anything special. 
The browser's console is already built to be an "infinite depth" explorer.


## LEARNING ABOUT FILTERING UNDEFINED  NULL   EMPTY  DATAS
1. The "Big Three" of Emptiness
To block these effectively, you first have to understand how they differ:

undefined: A variable has been declared but has not yet been assigned a value.

null: An intentional assignment of "no value."

Empty String (""): A string with a length of 0. It is technically a "value," but usually unwanted in forms.


2. Common Blocking Techniques
The "Loose" Check (The Easiest Way)
If you want to block null, undefined, 0, false, and "" all at once, use an if statement with the logical NOT (!) 
operator. These are all "falsy" values.

let input = ""; 

if (!input) {
  console.log("Access blocked: Value is empty, null, or undefined.");
}



##  IMPORTANT !VARIABLE  COMPARISON 
Comparison Table: What stays and what goes?
If you use the basic if (!value) check, here is how JavaScript evaluates different inputs:

Input Value,                     Evaluation,                 Will it be blocked?
undefined                        Falsy,                      Yes
null                             Falsy,                      Yes
"" (Empty string)"               Falsy,                      Yes
" " (String with space)"         Truthy,                     No (Unless you .trim())
0                                Falsy,                      Yes (Be careful!)
[] (Empty Array)                 Truthy,                     No



##  IMPORTANT   ABOUT   OBJECTS AND ARRAY
Quick Tip: If you are dealing with arrays or objects, !value won't work because [] and {} are 
considered "truthy" in JavaScript. You'll need to check value.length > 0 or Object.keys(value).length > 0.



##  MOST COMMON ERROR   ENCOUNTERED BY ME  ALWAYS US !VARIABLE FIRST BEFORE PROCEDURE
    inputString = null;

    if (inputString.length == 0) {
        //THIS WILL ERROR BECAUSE inputString is null and .length 
        //cannot be use because it is not a string value it is null
        console.log(`string is empty`);
    }

    if (!inputString) {
        //use this first before if (inputString.length == 0)
        //then use return or another stopper to avoid entering in
        //string filtering
        console.log(`not a valid string`);
        return;
    }


##  CONCAT( )
const str1 = "Hello";
const str2 = "World";

const combined = str1.concat(" ", str2, "!");
// Output: "Hello World!"



### FILTER  NUMBERS  STRING  DATE OBJECT  ARRAY  NULL UNDEFINED  


function fValidator(val) {
    //datatype 'string' 'number'  'null'  'undefined' 'array' 'object' 'date'  'unknown type'

    //code 1 valid, 2 empty, 3 invalid

    // 1. Block Null and Undefined
    if (val === null) return { dataType: 'null', code: 3, message: 'null' };
    if (val === undefined) return { dataType: 'undefined', code: 3, message: 'undefined' };

    // 2. Handle Numbers
    if (typeof val === 'number') {

        //return `Success: This is a number -> ${val}`;
        return { dataType: 'number', code: 1, message: `valid number ${val}` };
    }

    // 3. Handle Strings (including empty/whitespace checks)
    if (typeof val === 'string') {

        if (val.trim().length === 0) return { dataType: 'string', code: 2, message: 'empty string' };
        //return "Filtered: This is an empty string";

        //return `Success: This is a string -> "${val}"`;
        return { dataType: 'string', code: 1, message: `valid string ${val}` };
    }

    // 4. Handle Dates (Must check before generic Object)
    if (val instanceof Date) {
        // Check if the date is "Invalid Date" (e.g., new Date("wrong"))
        if (isNaN(val.getTime())) return { dataType: 'date', code: 3, message: 'invalid date' };
        //return "Filtered: This is an invalid Date object";

        //return `Success: This is a Date -> ${val.toISOString()}`;
        return { dataType: 'date', code: 1, message: `valid date ${JSON.stringify(val)}` };
    }

    // 5. Handle Arrays (Must check before generic Object)
    if (Array.isArray(val)) {
        if (val.length === 0) return { dataType: 'array', code: 2, message: 'empty array' };
        //return "Filtered: This is an empty array []";

        //return `Success: This is an array with ${val.length} items`;
        return { dataType: 'array', code: 1, message: `valid array ${JSON.stringify(val)}` };
    }

    // 6. Handle Objects
    if (typeof val === 'object') {
        if (Object.keys(val).length === 0) return { dataType: 'object', code: 2, message: 'empty object' };
        //return "Filtered: This is an empty object {}";

        //return `Success: This is an object with keys: ${Object.keys(val)}`;
        return { dataType: 'object', code: 1, message: `valid object ${JSON.stringify(val)}` };
    }

    //return "Unknown Type";
    return { dataType: 'unknown type', code: 3, message: 'unknown type' };
}

function fMain() {
    console.log(fValidator(2026));
    console.log(fValidator("Hello"));
    console.log(fValidator("   "));
    console.log(fValidator(new Date()));
    console.log(fValidator(new Date("invalid-string")));
    console.log(fValidator([10, 20]));
    console.log(fValidator([]));
    console.log(fValidator({ id: 1 }));
    console.log(fValidator({}));
    console.log(fValidator(null));

    console.log("\nEnd of fMain");
}
...fMain( );

/**
 * OUTPUT / RESULT:
{ dataType: 'number', code: 1, message: 'valid number 2026' }
{ dataType: 'string', code: 1, message: 'valid string Hello' }
{ dataType: 'string', code: 2, message: 'empty string' }
{
  dataType: 'date',
  code: 1,
  message: 'valid date "2026-02-22T11:41:48.584Z"'
}
{ dataType: 'date', code: 3, message: 'invalid date' }
{ dataType: 'array', code: 1, message: 'valid array [10,20]' }
{ dataType: 'array', code: 2, message: 'empty array' }
{ dataType: 'object', code: 1, message: 'valid object {"id":1}' }
{ dataType: 'object', code: 2, message: 'empty object' }
{ dataType: 'null', code: 3, message: 'null' } 

*/


### TYPEOF
1. typeof (The Label)
typeof is an operator that returns a string indicating the type of the unevaluated operand. It is best used for primitives
 (basic building blocks).

Use case: Checking if a variable is a string, number, boolean, or undefined.

The Bug: One famous JavaScript quirk is that typeof null returns "object".


###  INSTANCEOF


2. instanceof (The Factory)
instanceof is an operator that tests whether the prototype property of a constructor appears anywhere in the prototype 
chain of an object. It returns a boolean.

Use case: Checking for specific object types like Array, Date, or custom Classes.

Behavior: It checks the lineage. Since an Array is technically a "child" of the Object factory, an array will be an instance of both Array and Object.
 

// Data to test
const name = "ando";
const age = 25;
const list = [1, 2, 3];
const today = new Date();
const noValue = null;

// 1. typeof tests (returns a string)
const type1 = typeof name;
const type2 = typeof age;
const type3 = typeof list;   // Note: Returns "object"
const type4 = typeof noValue; // Note: Returns "object" (the JS bug)

// 2. instanceof tests (returns true/false)
const inst1 = list instanceof Array;
const inst2 = list instanceof Object;
const inst3 = today instanceof Date;
const inst4 = name instanceof String; // False! Primitives aren't "instances"

console.log(`typeof name: ${type1}`);
console.log(`typeof age: ${type2}`);
console.log(`typeof list: ${type3}`);
console.log(`typeof null: ${type4}`);
console.log("---");
console.log(`list is Array: ${inst1}`);
console.log(`list is Object: ${inst2}`);
console.log(`today is Date: ${inst3}`);
console.log(`name is instance of String: ${inst4}`);

/*
--- CONSOLE OUTPUT ---
typeof name: string
typeof age: number
typeof list: object
typeof null: object
---
list is Array: true
list is Object: true
today is Date: true
name is instance of String: false
*/


REMEMBER
Feature,                      typeof,                               instanceof
Returns,                      String (e.g., "number")    ,          Boolean (true or false)
Best For,                     Primitives (strings, numbers),        Objects (Arrays, Dates, Classes)
Array Check,                  Fails (returns "object") ,            Works (returns true)
Null Check,                   Returns "object",                     Returns false



###   SPREAD OPERATOR

This happens because of the Spread Operator (...).

When you place ... inside an array literal [] with a string, JavaScript performs what is 
called "String Spreading." It treats the string as a collection of individual characters 
and "unpacks" them one by one into the array.

 myString = "i'm not";

    console.log(`length is ${myString.length}`);

    [...myString].forEach((values, index) => {
        console.log(`index is ${index}\nvalue is: ${values} `);
    });
OUTPUT:
length is 7
index is 0
value is: i
index is 1
value is: '
index is 2
value is: m
index is 3
value is:
index is 4
value is: n
index is 5
value is: o
index is 6
value is: t



### DATE CONVERTION STRING,  STRING DATE TO DATE,  INPUT NEW DATE, NUMBER TO DATE


function dateReviewer() {
    // 1. Declaring actual date NOW
    const now = new Date();

    // 2. Converting String to Date object
    const stringDate = new Date("2026-12-25T15:30:00");

    // 3. Converting Number (Timestamp) to Date object
    // Note: Numbers represent milliseconds since Jan 1, 1970
    const timestampDate = new Date(1735689600000);

    // 4. Formatting Function
    // Using Intl.DateTimeFormat for a clean, single-line format
    const format = (d) => {
        const options = {
            month: 'long', day: 'numeric', year: 'numeric',
            hour: '2-digit', minute: '2-digit', second: '2-digit',
            hour12: true
        };
        return d.toLocaleString('en-US', options);
    };

    // Logging results as single-line strings
    console.log(`Now: ${format(now)}`);
    console.log(`From String: ${format(stringDate)}`);
    console.log(`From Number: ${format(timestampDate)}`);
}

dateReviewer();

/** * OUTPUT / RESULT:
 * Now: February 22, 2026, 07:58:56 PM
 * From String: December 25, 2026, 03:30:00 PM
 * From Number: January 1, 2025, 08:00:00 AM
 */


###  MANUAL  OBJECT ENTRIES
function fShowObject() {
    inputArray = [{ id: 1, name: 'ando' }, { id: 2, name: 'ben' }];
    getArray = inputArray.map(objectEntries => {
	//u can call the object manual when u access it in the array
        return `objectRow id: ${objectEntries.id}, name: ${objectEntries.name}`
    });

    console.log(`Result getArray ${JSON.stringify(getArray, null, 2)}`);
}
..call of func
fShowObject();
/*
OUTPUT:
Result getArray [
    "objectRow id: 1, name: ando",
    "objectRow id: 2, name: ben"
  ]
*/

### ANOTHER SAMPLE OBJECT ENTRIES
function fShowObjectEntries() {
    inputArray = [{ id: 1, name: 'ando' }, { id: 2, name: 'ben' }];
    getArray = inputArray.map(objectEntries => {

        myObjectEntries = Object.entries(objectEntries);

	//u can call the object manual when u access it I n Object.entries()
        return `cameFromObject.entries |${myObjectEntries[0][0]}|: ${myObjectEntries[0][1]}, |${myObjectEntries[1][0]}|: ${myObjectEntries[1][1]}`;
    });

    console.log(`Result getArray ${JSON.stringify(getArray, null, 2)}`);
}
..call
fShowObjectEntries();
/*
OUTPUT:
Result getArray [
    "cameFromObject.entries |id|: 1, |name|: ando",
    "cameFromObject.entries |id|: 2, |name|: ben"
  ]
*/


### REPLACE  MEMBER STRING

myString = "ando is comming";
myStringResult = myString.replace(/ /g, '1');
console.log(`FINAL result is ${myStringResult} `);
//OUTPUT:
FINAL result is ando1is coming

//REMEMBER  if u want to delete only the first item found from left
use .replace(' ', '1'); replace first space by '1'. but I u want to delete global us / /g 
code is .replace(/ /g, '1'); replace space by '1'


###  REPLACE    TOLOCALSTRING     NEW DATE   TOSTRING


    let inputDate = "1/2/2025 14:10:20";

    const cleanFormatMilitary = (d) => {
        // Ensure we are working with a Date object
        const dateObj = (d instanceof Date) ? d : new Date(d);

        return dateObj.toLocaleString('en-US', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false // This forces Military Time (24-hour)
        }).replace(',', '');
    };

    const resultString = cleanFormatMilitary(inputDate);

    // Verification
    const backToDate = new Date(resultString);
    const anothercleanFormat = cleanFormatMilitary(backToDate);

    console.log("String Result:", resultString);
    console.log("anothercleanFormat output:", anothercleanFormat);
    console.log("Back to Date check:", backToDate.toString());

    /*
    --- CONSOLE OUTPUT ---
    
    String Result: 01/02/2025 14:10:20
    anothercleanFormat output: 01/02/2025 14:10:20
    Back to Date check: Thu Jan 02 2025 14:10:20 GMT+0800 (Philippine Standard Time)
    */

###  ANOTHERTEST   REPLACE   MILITARYTIME  INSTANCEOF    NEW DATE   TOLOCALESTRING

    let inputDate = "1/2/2025 14:10:20";

    const cleanFormatMilitary = (d) => {
        // Ensure we are working with a Date object
        const dateObj = (d instanceof Date) ? d : new Date(d);

        return dateObj.toLocaleString('en-US', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false // This forces Military Time (24-hour)
        }).replace(',', '');
    };

    const resultString = cleanFormatMilitary(inputDate);

    // Verification
    let backToDate = new Date(resultString);
    backToDate = new Date(backToDate.toString());
    console.log("test toString output:", backToDate.toString());
    
    //
    const anothercleanFormat = cleanFormatMilitary(backToDate);

    console.log("String Result:", resultString);
    console.log("anothercleanFormat output:", anothercleanFormat);

    /*
    --- CONSOLE OUTPUT ---
    test toString output: Thu Jan 02 2025 14:10:20 GMT+0800 (Philippine Standard Time)
    String Result: 01/02/2025 14:10:20
    anothercleanFormat output: 01/02/2025 14:10:20    
    */


###  NOT MILITARY TIME  REPLACE  TOLACALESTRING  NEW DATE
let inputDate = new Date("2025-01-02T00:00:00");

// 1. The "Clean String" Format (No "at")
// We use 'en-GB' or custom options to get a clean DD/MM/YYYY, HH:mm:ss
const cleanFormat = (d) => {
    return d.toLocaleString('en-US', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: true
    }).replace(',', ''); // Removes the comma between date and time
};

const resultString = cleanFormat(inputDate);

// 2. Converting it back to a Date Object (Verification)
const backToDate = new Date(resultString);

console.log("String Result:", resultString);
console.log("Back to Date check:", backToDate.toString());

/*
--- CONSOLE OUTPUT ---
String Result: 01/02/2025 12:00:00 AM
Back to Date check: Thu Jan 02 2025 00:00:00 GMT+0000 (Coordinated Universal Time)
*/


###  TEST BY ME   TYPEOF  INSTANCEOF 

function fValidator(val) {
    //datatype 'string' 'number'  'null'  'undefined' 'array' 'object' 'date'  'unknown type'
    //code 1 valid, 2 empty, 3 invalid

    // 1. Block Null and Undefined
    if (val === null) return { dataType: 'null', code: 3, message: 'null' };
    if (val === undefined) return { dataType: 'undefined', code: 3, message: 'undefined' };

    // 2. Handle Numbers
    if (typeof val === 'number') {

        //return `Success: This is a number -> ${val}`;
        return { dataType: 'number', code: 1, message: `valid number ${val}` };
    }

    // 3. Handle Strings (including empty/whitespace checks)
    if (typeof val === 'string') {

        if (val.trim().length === 0) return { dataType: 'string', code: 2, message: 'empty string' };
        //return "Filtered: This is an empty string";

        //return `Success: This is a string -> "${val}"`;
        return { dataType: 'string', code: 1, message: `valid string ${val}` };
    }

    // 4. Handle Dates (Must check before generic Object)
    if (val instanceof Date) {
        // Check if the date is "Invalid Date" (e.g., new Date("wrong"))
        if (isNaN(val.getTime())) return { dataType: 'date', code: 3, message: 'invalid date' };
        //return "Filtered: This is an invalid Date object";

        //return `Success: This is a Date -> ${val.toISOString()}`;
        return { dataType: 'date', code: 1, message: `valid date ${JSON.stringify(val)}` };
    }

    // 5. Handle Arrays (Must check before generic Object)
    if (Array.isArray(val)) {
        if (val.length === 0) return { dataType: 'array', code: 2, message: 'empty array' };
        //return "Filtered: This is an empty array []";

        //return `Success: This is an array with ${val.length} items`;
        return { dataType: 'array', code: 1, message: `valid array ${JSON.stringify(val)}` };
    }

    // 6. Handle Objects
    if (typeof val === 'object') {
        if (Object.keys(val).length === 0) return { dataType: 'object', code: 2, message: 'empty object' };
        //return "Filtered: This is an empty object {}";

        //return `Success: This is an object with keys: ${Object.keys(val)}`;
        return { dataType: 'object', code: 1, message: `valid object ${JSON.stringify(val)}` };
    }

    //return "Unknown Type";
    return { dataType: 'unknown type', code: 3, message: 'unknown type' };
}

convertToMilitaryTime = (d) => {
    d = (d instanceof Date) ? d : new Date(d);
    options = {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false // This forces Military Time (24-hour)
    }
    return d.toLocaleString('en-US', options).replace(',', '');

};

trial1 = (inputDate) => {

    returnResult = fValidator(inputDate);

    console.log(`returnResult ${JSON.stringify(returnResult, null, 2)}`);

    if (!(returnResult.dataType == 'date')) {
        console.log(`trial1 not a valid date you input${inputDate}`);
        return;
    }

    if (returnResult.code > 1) {
        console.log(`trial1 not a valid date you input${inputDate} code error${retunResult.code}`);
        return;
    }

    console.log(`sucess the inputDate is:${inputDate}`);

};

trial2 = (inputDate) => {
    //converting it to date object
    inputNewDate = new Date(inputDate);
    //i input NewDate object to fValidator
    let returnResult = fValidator(inputNewDate);

    //but still filter string accept it 
    console.log(`returnResult ${JSON.stringify(returnResult, null, 2)}`);

    if (!(returnResult.dataType == 'date')) {
        console.log(`trial2 not a valid date you input${inputNewDate}`);
        return;
    }

    if (returnResult.code > 1) {
        console.log(`trial2 not a valid date you input${inputNewDate} code error${retunResult.code}`);
        return;
    }

    getMilitaryDate = convertToMilitaryTime(inputNewDate);
    //updatedInputNewDate = convertToMilitaryTime(inputNewDate);
    console.log(`sucess the inputNewDate is:${getMilitaryDate}`);

};

function fMain() {

    inputDate = '1/2/2026';
    trial1(inputDate);

    trial2(inputDate);
    console.log("\nEnd of fMain");
}

fMain();
console.log("\nEnd of prog...");
//OUTPUT
returnResult {
  "dataType": "string",
  "code": 1,
  "message": "valid string 1/2/2026"
}
trial1 not a valid date you input1/2/2026
returnResult {
  "dataType": "date",
  "code": 1,
  "message": "valid date \"2026-01-01T16:00:00.000Z\""
}
sucess the inputNewDate is:01/02/2026 00:00:00

End of fMain

End of prog...

REMEMBER YOUR FAULT  
Why it was failing for you:
Global Variables: Since you didn't use let or const, the variable returnResult became a "global" variable.

The Typo: In trial2, you assigned the validator result to retunResult (no 'r').

The Ghost Value: When you logged returnResult in trial2, the computer looked for that name, didn't find a 
new one in trial2, so it grabbed the "old" one left over from trial1.

AND REMEMBER THE toLocaleString('en-US', options).replace(',', '');
returns string if u use it in fValidator created by me it will filter by my string filter first, always use
new Date values when inputing it to fValidator


### FOR   ARROW FUNCTION (=>)  STANDARD FUNCTION  FUNCTION NAME( )  COMPARISON
1. Key Differences Overview   
Feature,                            Standard Function (function),                  Arrow Function (=>)
Syntax,Verbose:                     function name(args) { ... },                   Concise: const name = (args) => { ... }
this keyword,                       Defined by how the function is called.,        Defined by where the function was written.
Hoisting,                           Can be called before it's declared.,           Cannot be called before declaration.
Constructors,                       Can be used with new (classes).,               Cannot be used with new.
Arguments,                          Has its own arguments object.,                 Does not have an arguments object.



### ARGUMENTS OF OBJECT IN STANDARD FUNCTION

REMEMBER ARROW FUNCTION DOES NOT HAVE ARGMENTS OBJECT  


1. The Standard Function arguments
This is useful when you don't know how many items a user will send to your function (like a sum function that adds 2, 10, or 100 numbers).
function standardFunc() {
    console.log("--- Standard Function Log ---");
    console.log("Number of items passed:", arguments.length);
    console.log("First item:", arguments[0]);
    console.log("Second item:", arguments[1]);
}

standardFunc("Gemini", 2026);

/** * // OUTPUT / RESULT:
 * --- Standard Function Log ---
 * Number of items passed: 2
 * First item: Gemini
 * Second item: 2026
 */


2. The Arrow Function Behavior
Arrow functions do not have the arguments keyword. If you try to use it, the code will fail (unless it finds an arguments object from a
 parent function). Instead, we use the Rest Parameter (...args) to collect the values into a real array.


const arrowFunc = (...args) => {
    console.log("--- Arrow Function Log ---");
    // 'args' is a real Array we created using the ... syntax
    console.log("Items in arrow:", args.length);
    console.log("First item in arrow:", args[0]);
    console.log("Second item in arrow:", args[1]);
};

arrowFunc("AI", "JavaScript");

/** * // OUTPUT / RESULT:
 * --- Arrow Function Log ---
 * Items in arrow: 2
 * First item in arrow: AI
 * Second item in arrow: JavaScript
 */

REMEMBER:
Why this is important for your records:
Standard Function: arguments is "automatic." You don't have to define it, but it is not a real array (you can't use .map() or 
.filter() on it easily).

Arrow Function: You must define ...args if you want to capture multiple inputs. The advantage is that args is a real array, 
so you can use all the cool JavaScript array methods on it immediately.




#############################################33
### STANDBY
let inputDate = "2026-12-25T15:30:00";

// Step 1: Convert the string into a Date Object
const dateObject = new Date(inputDate);

// Step 2: Now check if it's a valid Date instance
if (!(dateObject instanceof Date) || isNaN(dateObject)) {
    console.log(`invalid input of date the value ${inputDate}`);
    return;
}

console.log(`result is ${myFormat(dateObject)}`);

/*
--- CONSOLE OUTPUT ---
result is [Whatever your myFormat function produces]
*/


function isValidDate(dateString) {
    const d = new Date(dateString);
    
    // 1. Check if it's a Date object
    // 2. Check if the time value is a valid number
    const isValid = d instanceof Date && !isNaN(d.getTime());
    
    console.log(`Input: "${dateString}" | Result: ${isValid ? "VALID" : "INVALID"}`);
    return isValid;
}

isValidDate("2026-12-25"); // VALID
isValidDate("apple-pie");   // INVALID



##
// Function for Humans
const myFormat = (d) => d.toLocaleString('en-US', { dateStyle: 'long', timeStyle: 'medium' });

// Function for the Machine (Safe for new Date)
const toMachine = (d) => d.toISOString(); 

let inputDate = "1/2/2025"; // M/D/Y format

// 1. FIRST CONVERSION
inputDate = new Date(inputDate);
console.log(`result is ${myFormat(inputDate)}`);

// 2. THE SECRET STEP
// Instead of storing the "Pretty" version, store the "Machine" version
let machineValue = toMachine(inputDate); 

// 3. SECOND CONVERSION
// Now new Date() works perfectly because ISO format is standardized
inputDate = new Date(machineValue);

if (!(inputDate instanceof Date) || isNaN(inputDate)) {
    console.log(`invalid input of date the value ${inputDate}`);
    return;
}

console.log(`FINAL result is ${myFormat(inputDate)}`);

/*
--- CONSOLE OUTPUT ---
result is January 2, 2025 at 12:00:00 AM
FINAL result is January 2, 2025 at 12:00:00 AM
*/



get this
Summary of Best Practice
If you want to pass a date back and forth between "String" and "Date object" multiple times, always use toISOString() or toDateString() for the storage, and save the "pretty" toLocaleString() only for the final printout.
#### END OF STANDBY





NOTE: TOPICS TO BE GET
STRICLY BLOCKERS FOR ISNAN ISOBJECT ISARRAY  ISUNDEFINED  ISSTRING
DATE CONVERSION STRING TO DATE   DATE TO STRING

# END JS
###############################







###################
#PYTHON


# END PYTHON
##############